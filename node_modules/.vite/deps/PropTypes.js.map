{
  "version": 3,
  "sources": ["../../proptypes/src/index.js"],
  "sourcesContent": ["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTypes\n */\n\n'use strict';\n\n\n// The Symbol used to tag the ReactElement type. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE =\n  (typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element')) ||\n  0xeac7;\n\nvar ReactElement = {};\n\n/**\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */\nReactElement.isValidElement = function(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n};\n\nvar ReactPropTypeLocationNames = {\n  prop: 'prop',\n  context: 'context',\n  childContext: 'child context',\n};\n\n\n\n\nvar emptyFunction = {\n  thatReturns: function(what) {\n    return function(){ return what; };\n  }\n};\n\n\n\nvar ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\nfunction getIteratorFn(maybeIterable) {\n  var iteratorFn = maybeIterable && (\n    (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL]\n  );\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n}\n\n\n\n/**\n * Collection of methods that allow declaration and validation of props that are\n * supplied to React components. Example usage:\n *\n *   var Props = require('ReactPropTypes');\n *   var MyArticle = React.createClass({\n *     propTypes: {\n *       // An optional string prop named \"description\".\n *       description: Props.string,\n *\n *       // A required enum prop named \"category\".\n *       category: Props.oneOf(['News','Photos']).isRequired,\n *\n *       // A prop named \"dialog\" that requires an instance of Dialog.\n *       dialog: Props.instanceOf(Dialog).isRequired\n *     },\n *     render: function() { ... }\n *   });\n *\n * A more formal specification of how these methods are used:\n *\n *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n *   decl := ReactPropTypes.{type}(.isRequired)?\n *\n * Each and every declaration produces a function with the same signature. This\n * allows the creation of custom validation functions. For example:\n *\n *  var MyLink = React.createClass({\n *    propTypes: {\n *      // An optional string or URI prop named \"href\".\n *      href: function(props, propName, componentName) {\n *        var propValue = props[propName];\n *        if (propValue != null && typeof propValue !== 'string' &&\n *            !(propValue instanceof URI)) {\n *          return new Error(\n *            'Expected a string or an URI for ' + propName + ' in ' +\n *            componentName\n *          );\n *        }\n *      }\n *    },\n *    render: function() {...}\n *  });\n *\n * @internal\n */\n\nvar ANONYMOUS = '<<anonymous>>';\n\nvar ReactPropTypes = {\n  array: createPrimitiveTypeChecker('array'),\n  bool: createPrimitiveTypeChecker('boolean'),\n  func: createPrimitiveTypeChecker('function'),\n  number: createPrimitiveTypeChecker('number'),\n  object: createPrimitiveTypeChecker('object'),\n  string: createPrimitiveTypeChecker('string'),\n  symbol: createPrimitiveTypeChecker('symbol'),\n\n  any: createAnyTypeChecker(),\n  arrayOf: createArrayOfTypeChecker,\n  element: createElementTypeChecker(),\n  instanceOf: createInstanceTypeChecker,\n  node: createNodeChecker(),\n  objectOf: createObjectOfTypeChecker,\n  oneOf: createEnumTypeChecker,\n  oneOfType: createUnionTypeChecker,\n  shape: createShapeTypeChecker,\n};\n\nfunction createChainableTypeChecker(validate) {\n  function checkType(\n    isRequired,\n    props,\n    propName,\n    componentName,\n    location,\n    propFullName\n  ) {\n    componentName = componentName || ANONYMOUS;\n    propFullName = propFullName || propName;\n    if (props[propName] == null) {\n      var locationName = ReactPropTypeLocationNames[location];\n      if (isRequired) {\n        return new Error(\n          `Required ${locationName} \\`${propFullName}\\` was not specified in ` +\n          `\\`${componentName}\\`.`\n        );\n      }\n      return null;\n    } else {\n      return validate(props, propName, componentName, location, propFullName);\n    }\n  }\n\n  var chainedCheckType = checkType.bind(null, false);\n  chainedCheckType.isRequired = checkType.bind(null, true);\n\n  return chainedCheckType;\n}\n\nfunction createPrimitiveTypeChecker(expectedType) {\n  function validate(props, propName, componentName, location, propFullName) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== expectedType) {\n      var locationName = ReactPropTypeLocationNames[location];\n      // `propValue` being instance of, say, date/regexp, pass the 'object'\n      // check, but we can offer a more precise error message here rather than\n      // 'of type `object`'.\n      var preciseType = getPreciseType(propValue);\n\n      return new Error(\n        `Invalid ${locationName} \\`${propFullName}\\` of type ` +\n        `\\`${preciseType}\\` supplied to \\`${componentName}\\`, expected ` +\n        `\\`${expectedType}\\`.`\n      );\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createAnyTypeChecker() {\n  return createChainableTypeChecker(emptyFunction.thatReturns(null));\n}\n\nfunction createArrayOfTypeChecker(typeChecker) {\n  function validate(props, propName, componentName, location, propFullName) {\n    var propValue = props[propName];\n    if (!Array.isArray(propValue)) {\n      var locationName = ReactPropTypeLocationNames[location];\n      var propType = getPropType(propValue);\n      return new Error(\n        `Invalid ${locationName} \\`${propFullName}\\` of type ` +\n        `\\`${propType}\\` supplied to \\`${componentName}\\`, expected an array.`\n      );\n    }\n    for (var i = 0; i < propValue.length; i++) {\n      var error = typeChecker(\n        propValue,\n        i,\n        componentName,\n        location,\n        `${propFullName}[${i}]`\n      );\n      if (error instanceof Error) {\n        return error;\n      }\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createElementTypeChecker() {\n  function validate(props, propName, componentName, location, propFullName) {\n    if (!ReactElement.isValidElement(props[propName])) {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        `Invalid ${locationName} \\`${propFullName}\\` supplied to ` +\n        `\\`${componentName}\\`, expected a single ReactElement.`\n      );\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createInstanceTypeChecker(expectedClass) {\n  function validate(props, propName, componentName, location, propFullName) {\n    if (!(props[propName] instanceof expectedClass)) {\n      var locationName = ReactPropTypeLocationNames[location];\n      var expectedClassName = expectedClass.name || ANONYMOUS;\n      var actualClassName = getClassName(props[propName]);\n      return new Error(\n        `Invalid ${locationName} \\`${propFullName}\\` of type ` +\n        `\\`${actualClassName}\\` supplied to \\`${componentName}\\`, expected ` +\n        `instance of \\`${expectedClassName}\\`.`\n      );\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createEnumTypeChecker(expectedValues) {\n  if (!Array.isArray(expectedValues)) {\n    return createChainableTypeChecker(function() {\n      return new Error(\n        `Invalid argument supplied to oneOf, expected an instance of array.`\n      );\n    });\n  }\n\n  function validate(props, propName, componentName, location, propFullName) {\n    var propValue = props[propName];\n    for (var i = 0; i < expectedValues.length; i++) {\n      if (propValue === expectedValues[i]) {\n        return null;\n      }\n    }\n\n    var locationName = ReactPropTypeLocationNames[location];\n    var valuesString = JSON.stringify(expectedValues);\n    return new Error(\n      `Invalid ${locationName} \\`${propFullName}\\` of value \\`${propValue}\\` ` +\n      `supplied to \\`${componentName}\\`, expected one of ${valuesString}.`\n    );\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createObjectOfTypeChecker(typeChecker) {\n  function validate(props, propName, componentName, location, propFullName) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== 'object') {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        `Invalid ${locationName} \\`${propFullName}\\` of type ` +\n        `\\`${propType}\\` supplied to \\`${componentName}\\`, expected an object.`\n      );\n    }\n    for (var key in propValue) {\n      if (propValue.hasOwnProperty(key)) {\n        var error = typeChecker(\n          propValue,\n          key,\n          componentName,\n          location,\n          `${propFullName}.${key}`\n        );\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createUnionTypeChecker(arrayOfTypeCheckers) {\n  if (!Array.isArray(arrayOfTypeCheckers)) {\n    return createChainableTypeChecker(function() {\n      return new Error(\n        `Invalid argument supplied to oneOfType, expected an instance of array.`\n      );\n    });\n  }\n\n  function validate(props, propName, componentName, location, propFullName) {\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (\n        checker(props, propName, componentName, location, propFullName) == null\n      ) {\n        return null;\n      }\n    }\n\n    var locationName = ReactPropTypeLocationNames[location];\n    return new Error(\n      `Invalid ${locationName} \\`${propFullName}\\` supplied to ` +\n      `\\`${componentName}\\`.`\n    );\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createNodeChecker() {\n  function validate(props, propName, componentName, location, propFullName) {\n    if (!isNode(props[propName])) {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        `Invalid ${locationName} \\`${propFullName}\\` supplied to ` +\n        `\\`${componentName}\\`, expected a ReactNode.`\n      );\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createShapeTypeChecker(shapeTypes) {\n  function validate(props, propName, componentName, location, propFullName) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== 'object') {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        `Invalid ${locationName} \\`${propFullName}\\` of type \\`${propType}\\` ` +\n        `supplied to \\`${componentName}\\`, expected \\`object\\`.`\n      );\n    }\n    for (var key in shapeTypes) {\n      var checker = shapeTypes[key];\n      if (!checker) {\n        continue;\n      }\n      var error = checker(\n        propValue,\n        key,\n        componentName,\n        location,\n        `${propFullName}.${key}`\n      );\n      if (error) {\n        return error;\n      }\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction isNode(propValue) {\n  switch (typeof propValue) {\n    case 'number':\n    case 'string':\n    case 'undefined':\n      return true;\n    case 'boolean':\n      return !propValue;\n    case 'object':\n      if (Array.isArray(propValue)) {\n        return propValue.every(isNode);\n      }\n      if (propValue === null || ReactElement.isValidElement(propValue)) {\n        return true;\n      }\n\n      var iteratorFn = getIteratorFn(propValue);\n      if (iteratorFn) {\n        var iterator = iteratorFn.call(propValue);\n        var step;\n        if (iteratorFn !== propValue.entries) {\n          while (!(step = iterator.next()).done) {\n            if (!isNode(step.value)) {\n              return false;\n            }\n          }\n        } else {\n          // Iterator will provide entry [k,v] tuples rather than values.\n          while (!(step = iterator.next()).done) {\n            var entry = step.value;\n            if (entry) {\n              if (!isNode(entry[1])) {\n                return false;\n              }\n            }\n          }\n        }\n      } else {\n        return false;\n      }\n\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction isSymbol(propType, propValue) {\n  // Native Symbol.\n  if (propType === 'symbol') {\n    return true;\n  }\n\n  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n  if (propValue['@@toStringTag'] === 'Symbol') {\n    return true;\n  }\n\n  // Fallback for non-spec compliant Symbols which are polyfilled.\n  if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n    return true;\n  }\n\n  return false;\n}\n\n// Equivalent of `typeof` but with special handling for array and regexp.\nfunction getPropType(propValue) {\n  var propType = typeof propValue;\n  if (Array.isArray(propValue)) {\n    return 'array';\n  }\n  if (propValue instanceof RegExp) {\n    // Old webkits (at least until Android 4.0) return 'function' rather than\n    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n    // passes PropTypes.object.\n    return 'object';\n  }\n  if (isSymbol(propType, propValue)) {\n    return 'symbol';\n  }\n  return propType;\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// See `createPrimitiveTypeChecker`.\nfunction getPreciseType(propValue) {\n  var propType = getPropType(propValue);\n  if (propType === 'object') {\n    if (propValue instanceof Date) {\n      return 'date';\n    } else if (propValue instanceof RegExp) {\n      return 'regexp';\n    }\n  }\n  return propType;\n}\n\n// Returns class name of the object, if any.\nfunction getClassName(propValue) {\n  if (!propValue.constructor || !propValue.constructor.name) {\n    return ANONYMOUS;\n  }\n  return propValue.constructor.name;\n}\n\nexport default ReactPropTypes;\n"],
  "mappings": "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",
  "names": ["REACT_ELEMENT_TYPE", "Symbol", "for", "ReactElement", "isValidElement", "object", "$$typeof", "ReactPropTypeLocationNames", "prop", "context", "childContext", "emptyFunction", "thatReturns", "what", "ITERATOR_SYMBOL", "iterator", "FAUX_ITERATOR_SYMBOL", "getIteratorFn", "maybeIterable", "iteratorFn", "ANONYMOUS", "ReactPropTypes", "array", "createPrimitiveTypeChecker", "bool", "func", "number", "string", "symbol", "any", "createAnyTypeChecker", "arrayOf", "createArrayOfTypeChecker", "element", "createElementTypeChecker", "instanceOf", "createInstanceTypeChecker", "node", "createNodeChecker", "objectOf", "createObjectOfTypeChecker", "oneOf", "createEnumTypeChecker", "oneOfType", "createUnionTypeChecker", "shape", "createShapeTypeChecker", "createChainableTypeChecker", "validate", "checkType", "isRequired", "props", "propName", "componentName", "location", "propFullName", "locationName", "Error", "chainedCheckType", "bind", "expectedType", "propValue", "propType", "getPropType", "preciseType", "getPreciseType", "typeChecker", "Array", "isArray", "i", "length", "error", "expectedClass", "expectedClassName", "name", "actualClassName", "getClassName", "expectedValues", "valuesString", "JSON", "stringify", "key", "hasOwnProperty", "arrayOfTypeCheckers", "checker", "isNode", "shapeTypes", "every", "call", "step", "entries", "next", "done", "value", "entry", "isSymbol", "RegExp", "Date", "constructor"]
}
